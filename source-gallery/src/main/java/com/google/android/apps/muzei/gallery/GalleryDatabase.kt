/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.android.apps.muzei.gallery

import android.arch.persistence.db.SupportSQLiteDatabase
import android.arch.persistence.room.Database
import android.arch.persistence.room.Room
import android.arch.persistence.room.RoomDatabase
import android.arch.persistence.room.migration.Migration
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Binder
import android.util.Log
import androidx.net.toUri

/**
 * Database for accessing Gallery data
 */
@Database(entities = [(ChosenPhoto::class), (Metadata::class)], version = 6)
internal abstract class GalleryDatabase : RoomDatabase() {

    companion object {
        private const val TAG = "GalleryDatabase"

        @Volatile
        private var instance: GalleryDatabase? = null

        fun getInstance(context: Context): GalleryDatabase =
                instance ?: synchronized(this) {
                    instance ?: buildDatabase(context).also { instance = it }
                }

        private fun buildDatabase(context: Context) =
                Room.databaseBuilder(context.applicationContext, GalleryDatabase::class.java,
                        "gallery_source.db")
                        .addMigrations(
                                MIGRATION_1_2,
                                MIGRATION_2_3,
                                MIGRATION_3_4,
                                Migration4_5(context.applicationContext),
                                MIGRATION_5_6)
                        .build()

        private val MIGRATION_1_2 = object : Migration(1, 2) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("DROP TABLE IF EXISTS metadata_cache")
                database.execSQL("CREATE TABLE metadata_cache ("
                        + "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,"
                        + "uri TEXT NOT NULL,"
                        + "datetime INTEGER,"
                        + "location TEXT,"
                        + "UNIQUE (uri) ON CONFLICT REPLACE)")
            }
        }

        private val MIGRATION_2_3 = object : Migration(2, 3) {
            override fun migrate(database: SupportSQLiteDatabase) {
                database.execSQL("ALTER TABLE chosen_photos" + " ADD COLUMN is_tree_uri INTEGER")
            }
        }

        private val MIGRATION_3_4 = object : Migration(3, 4) {
            override fun migrate(database: SupportSQLiteDatabase) {
                // Due to an issue with upgrading version 2 to 3, some users might have the
                // COLUMN_NAME_IS_TREE_URI column and some might not. Awkward.
                // We'll check if the column exists and add it if it doesn't exist
                val pragma = database.query("PRAGMA table_info(chosen_photos)")
                var columnExists = false
                while (pragma.moveToNext()) {
                    val columnIndex = pragma.getColumnIndex("name")
                    if (columnIndex != -1 && pragma.getString(columnIndex) == "is_tree_uri") {
                        columnExists = true
                    }
                }
                pragma.close()
                if (!columnExists) {
                    database.execSQL("ALTER TABLE chosen_photos" + " ADD COLUMN is_tree_uri INTEGER")
                }
            }
        }

        /**
         * Migration4_5 is a bit different since we need access to a Context in order to double check
         * that we've successfully persisted URI permissions to Uris generated by our own app.
         */
        private class Migration4_5 internal constructor(context: Context) : Migration(4, 5) {
            private val applicationContext: Context = context.applicationContext

            override fun migrate(database: SupportSQLiteDatabase) {
                // Double check all existing artwork to make sure we've
                // persisted URI permissions where possible
                val contentResolver = applicationContext.contentResolver
                database.query("SELECT uri FROM chosen_photos")?.use {
                    while (it.moveToNext()) {
                        val imageUri = it.getString(0).toUri()
                        val cachedFile = GalleryProvider.getCacheFileForUri(applicationContext, imageUri)
                        if (cachedFile == null || !cachedFile.exists()) {
                            // If we don't have a cached file, then we must have permission to the
                            // underlying URI
                            val haveUriPermission = applicationContext.checkUriPermission(imageUri,
                                    Binder.getCallingPid(), Binder.getCallingUid(),
                                    Intent.FLAG_GRANT_READ_URI_PERMISSION) == PackageManager.PERMISSION_GRANTED
                            if (!haveUriPermission) {
                                // On API 25 and lower, we don't get URI permissions to URIs
                                // from our own package so we manage those URI permissions manually
                                try {
                                    contentResolver.call(imageUri, "takePersistableUriPermission",
                                            imageUri.toString(), null)
                                } catch (e: Exception) {
                                    Log.w(TAG, "Unable to manually persist uri permissions to $imageUri", e)
                                }

                            }
                        }
                    }
                }
            }
        }

        private val MIGRATION_5_6 = object : Migration(5, 6) {
            override fun migrate(database: SupportSQLiteDatabase) {
                // Handle Chosen Photos
                database.execSQL("UPDATE chosen_photos "
                        + "SET is_tree_uri = 0 "
                        + "WHERE is_tree_uri IS NULL")
                database.execSQL("CREATE TABLE chosen_photos2 ("
                        + "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,"
                        + "uri TEXT NOT NULL,"
                        + "is_tree_uri INTEGER NOT NULL,"
                        + "UNIQUE (uri) ON CONFLICT REPLACE)")
                database.execSQL("INSERT INTO chosen_photos2 " + "SELECT * FROM chosen_photos")
                database.execSQL("DROP TABLE chosen_photos")
                database.execSQL("ALTER TABLE chosen_photos2 RENAME TO chosen_photos")
                database.execSQL("CREATE UNIQUE INDEX index_chosen_photos_uri " + "ON chosen_photos (uri)")

                // Handle Metadata
                database.execSQL("CREATE TABLE metadata_cache2 ("
                        + "_id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,"
                        + "uri TEXT NOT NULL,"
                        + "datetime INTEGER,"
                        + "location TEXT,"
                        + "UNIQUE (uri) ON CONFLICT REPLACE)")
                database.execSQL("INSERT INTO metadata_cache2 " + "SELECT * FROM metadata_cache")
                database.execSQL("DROP TABLE metadata_cache")
                database.execSQL("ALTER TABLE metadata_cache2 RENAME TO metadata_cache")
                database.execSQL("CREATE UNIQUE INDEX index_metadata_cache_uri " + "ON metadata_cache (uri)")
            }
        }
    }

    internal abstract fun chosenPhotoDao(): ChosenPhotoDao

    internal abstract fun metadataDao(): MetadataDao
}
